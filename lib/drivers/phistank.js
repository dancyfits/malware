/**
* Required modules
**/
const crypto      = require('crypto');
const async       = require('async');
const url         = require('url');
const request     = require('request');
const S           = require('string');
const _           = require('underscore');
const Constants   = require('../constants');

/**
* Object to expose
**/
var PhisTank = {};

/**
* Generates a hash that we can use to check against our local cache
**/
PhisTank.getHash = function(payload, link, fn) {

  // remove the query and hash params
  var uri = url.parse( (link || '').toLowerCase() );

  // remove the hash
  url_obj.hash = '';
  url_obj.search = '';

  // create the hash object
  sha = crypto.createHash('sha256');
  sha.update( url.format(url_obj) );
  fn(null, sha.digest('base64').prefix);

};

/**
* Does the actual check
**/
PhisTank.check = function(payload, link, fn) {

  // parse the url
  var uri = url.parse(link);

  // get the hash
  PhisTank.getHash(payload, link, function(err, hash) {

    // handle a error if any
    if(err) {

      // output error
      payload.error('Something went wrong while generating the hash for PhisTank from link ' + link, err);

      // finish
      return fn(err);

    }

    // the key to use for caching
    var cachingKey = [

      'passmarked',
      'phistank',
      hash

    ].join(':');

    // check the cache
    payload.get(cachingKey, function(err, cachedResults) {

      // handle any errors
      if(err) {

        // output to stderr
        payload.error('Problem checking cache for Phistank results', err);

        // even if the cache is not working still continue
        // return fn(err);

      }

      // was it cached ?
      if(!cachedResults) return fn(null, []);

      // the value
      var detections = [];

      // split the results
      var results = null;

      // try to parse the results
      try {

        // parse it
        results = JSON.parse(cachedResults);

      } catch(err) {

        // failed to parse
        payload.error('Failed to parse the response from Cache for Phistank', err);

        // finish
        return fn(null, []);

      }

      // go through the results one by one
      async.each(results || [], function(result, cb) {

        // the type we will go searching for
        var type = null;

        // get the keys of the known types
        var knownKeys = _.keys(Constants.DETECTIONS);

        // get the known types
        for(var i = 0; i < knownKeys.length; i++) {

          // does this type match ?
          if( Constants.DETECTIONS[knownKeys[i]] === '' )
            type = Constants.DETECTIONS[knownKeys[i]];

        }

        // must be a known type
        if(!type) return cb(null);

        // add it
        detections.push({
          
          source:       Constants.PHISTANK_SOURCE, // API name
          provider:     Constants.PHISTANK_COMPANY, // Company Name
          preview:      result.phish_detail_url, // Preview url to view why online
          website:      Constants.PHISTANK_WEBSITE,
          result:       results,
          type:         Constants.DETECTIONS.PHISHING,
          url:          link

        });

        // done
        cb(null);

      }, function(err) {

        // handle the output
        if(err) {

          // output as error
          payload.error('Something went wrong while parsing the results from SAFE BROWSING: ' + results, err);

        }

        // finish with the error if given
        fn(err, detections);

      });

      // return
      fn(null, detections)

    });

  });


};

/**
* Expose the given object
**/
module.exports = exports = PhisTank;